# 翻译@Auto Layout Guide（自动布局指南）

- 原文：[Auto Layout Guide](https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/index.html#//apple_ref/doc/uid/TP40010853)
- 作者：[Apple](https://developer.apple.com/library/content/navigation/)

---

## Getting Started（新手上路）

### Anatomy of a Constraint（约束详解）

视图结构的布局通过一系列线性等式来定义。每个约束代表一个等式。你的目标就是定义这些等式，其有且仅有唯一解。

等式范例如下：

![图5](http://ohqrsnfvu.bkt.clouddn.com/auto-layout-guide/%E5%9B%BE5.png)

上述约束规定红色视图的前部位于蓝色视图后部后方8pt的位置。代表这个约束的等式由如下部分组成：

- **Item 1（元素1）**。等式中的第一个元素——在这里，即红色视图。等式中的元素必须是视图或布局参照（layout guide）。
- **Attribute 1（属性1）**。元素1被约束的属性——在这里，即红色视图的前部。
- **Multiplier（倍数）**。属性2的值会乘以这个浮点数。在这里，倍数是1.0。
- **Item 2（对象2）**。等式中的第二个元素——在这里，即蓝色视图。与元素1不同，其可以为空。
- **Attribute 2（属性2）**。元素2被约束的属性——在这里，即蓝色视图的后部。如果元素2为空，此处必须是`Not an Attribute`。
- **Constant（常量）**。一个浮点数偏移量——在这里，即8.0。这个值会和属性2的值相加。

大多数约束定义界面上两个元素之间的关系。这些元素不是视图，就是布局参照。约束还可以定义同一个元素两个属性之间的关系。例如，为一个元素的宽和高设定比例关系。设置可以直接为元素的宽或高设置常量。设定常量时，第二个元素为空，第二个属性为`Not An Attribute`，倍数为0.0。

#### Auto Layout Attributes（自动布局属性）

对于自动布局来说，属性就是可以被约束的特征。总体上，这包括视图的四边（前部，后部，上部，下部），以及宽，高，水平和垂直方向上的中心。文字视图还会有一到两个基准线。

![图6](http://ohqrsnfvu.bkt.clouddn.com/auto-layout-guide/%E5%9B%BE6.png)

所有属性，详见枚举[NSLayoutAttribute](https://developer.apple.com/documentation/uikit/nslayoutattribute)。

>虽然OS X和iOS都使用这个枚举，但它们对某些值的解释不同。所以，查看文档时，要注意区分平台。

#### Sample Equations（等式样例）

不同的参数和属性，创造出代表不同约束的等式。例如，定义两个视图之间的间距，让视图一边对齐，定义两个视图之间的相对大小关系，甚至定义视图自身的宽高比。然而，并非所有的属性都可以互相配对使用。

属性分为两类。尺寸属性（例如，宽和高）以及位置属性（例如前部，左部，和上部）。尺寸属性用于定义元素的大小，与位置无关。位置属性用于定义元素的相对位置，与尺寸无关。

了解了它们的区别之后，要记住下述规则：

- 不能根据位置属性约束尺寸属性。
- 不能为位置属性设置常量。
- 不能对位置属性使用"无意义"的倍数（除了1.0以外的值）。
- 不能在垂直位置属性和水平位置属性之间定义约束。
- 同样是位置属性，不能在前部/后部，和左部/右部之间定义约束。

例如，没有其他参考，单单设置一个元素的上部为常量20.0毫无意义。约束位置属性时，必须相对于其他元素定义。再例如，相对于父视图上部下方20pt。然而，将一个元素的高度设定为20.0就完全可行。更多信息，详见[常量的解释]()。

代码3-1给出了一组常见约束的等式。

>本章所有等式都使用伪代码表示。要查看代码实例，详见[代码创建约束](https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/ProgrammaticallyCreatingConstraints.html#//apple_ref/doc/uid/TP40010853-CH16-SW1)或[自动布局手册](https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/LayoutUsingStackViews.html#//apple_ref/doc/uid/TP40010853-CH3-SW1)。

**代码3-1** 代表常见约束的等式

```
// 设置高度约束
View.height = 0.0 * NotAnAttribute + 40.0
 
// 设置两个按钮之间的间距
Button_2.leading = 1.0 * Button_1.trailing + 8.0
 
// 对齐两个按钮的前部
Button_1.leading = 1.0 * Button_2.leading + 0.0
 
// 让两个按钮宽度相同
Button_1.width = 1.0 * Button_2.width + 0.0
 
// 让一个视图的中心与其父视图对齐
View.centerX = 1.0 * Superview.centerX + 0.0
View.centerY = 1.0 * Superview.centerY + 0.0
 
// 固定视图的宽高比
View.height = 2.0 * View.width + 0.0

```

#### Equality, Not Assignment（相等，而非赋值）

请注意，上例中等式两端是相等关系，而非赋值。

自动布局解析这些等式时，并不会将右边的值赋给左边的值。相反，像解方程一样，它会计算等式成立时属性1和属性2的值。这意味着等式中元素的顺序无关紧要。例如，代码3-2同3-1中相应的示例完全一致。

**代码3-2** 颠倒等式中元素的顺序

```
// 设置两个按钮之间的间距
Button_1.trailing = 1.0 * Button_2.leading - 8.0
 
// 对齐两个按钮的前部
Button_2.leading = 1.0 * Button_1.leading + 0.0
 
// 让两个按钮宽度相同
Button_2.width = 1.0 * Button.width + 0.0
 
// 让一个视图的中心与其父视图对齐
Superview.centerX = 1.0 * View.centerX + 0.0
Superview.centerY = 1.0 * View.centerY + 0.0
 
// 固定视图的宽高比
View.width = 0.5 * View.height + 0.0
```

>调整元素顺序时，确保同时调整倍数和常量的值。例如，常量8.0变为-8.0；倍数2.0变为0.5。常量0.0和倍数1.0无需调整。

在自动布局中，同一个问题的解决方式有很多种。理想情况下，选择最能够体现你意图的方式。然而，不同开发者对此的选择毫无疑问会有所不同。不管怎样，选择一种，坚持使用，如此，会避免很多问题。例如，本指南使用下述规则：

1. 倍数最好为整数，而非分数。
2. 常量最好为正数，而非负数。
3. 如果可能，元素应该按照布局中的顺序出现：自上至下，自左至右，自前至后。

#### Creating Nonambiguous, Satisfiable Layouts（创建明确，可满足的约束）

自动布局的关键在于代表约束的等式有且仅有唯一解。模糊的约束有一个以上解。无法满足的约束没有解。

总之，视图的尺寸和位置都必须被约束。假设父视图的尺寸已经确定（例如，父视图是iOS中一个场景（scene）的根视图），对于每个子视图来说，要创建一个明确，可满足的布局，每个方向上各需要两条约束（不包括父视图的约束）。然而，至于使用哪些约束，可以有很多选择。例如，下面的三个布局都是明确，可满足的（这里只显示了水平方向上的约束）。

![图7](http://ohqrsnfvu.bkt.clouddn.com/auto-layout-guide/%E5%9B%BE7.png)

- 第一个布局相对于父视图的前部约束视图的前部，并给了视图一个固定宽度。因此，尾部的位置可以根据这两条约束确定。
- 第二个布局相对于父视图的前部约束视图的前部，并相对于父视图的尾部约束视图的尾部。因此，视图的宽度可以根据这两条约束，以及父视图宽度确定。
- 第三个布局相对于父视图的前部约束视图的前部，并将视图和父视图的中心点对齐。因此，视图的宽度和尾部可以根据这两条约束，以及父视图的宽度确定。

注意，每个布局都有一个子视图，两条水平约束。各例中，都完整约束了视图的宽度及水平位置。这意味着水平方向上的布局是明确，可满足的。然而，这些布局的效用并不相同。想象一下如果父视图的尺寸改变，各个布局中视图的尺寸和位置会如何变化。

对于第一个布局，视图的宽度不会改变。大多数时候，这不是我们想要的效果。实际上，一般来说，不应该将视图的尺寸写死（即设定常量）。自动布局是为创建动态布局而生的。如果写死，我们就是去了使用它的意义。

也许很难一眼看出，但第二个和第三个布局的行为是相同的：随着父视图的尺寸变化，视图与其的左右间距不变。然而，这两个布局使用场景并不一定相同。第二个布局一般来说更好理解，但第三个布局可能更有用，特别需要中心对齐一组视图时。再说一次，根据效果选择布局方式。

下面看看复杂一点的情况。假设iPhone上有两个视图要并排显示。二者四周都有留空，并且二者同宽。而且，即使设备旋转，布局不变。

下图显示了它们在设备呈垂直和水平方向时的效果：

![图8](http://ohqrsnfvu.bkt.clouddn.com/auto-layout-guide/%E5%9B%BE8.png)

该怎样添加约束呢？下图的方式简单明了：

![图9](http://ohqrsnfvu.bkt.clouddn.com/auto-layout-guide/%E5%9B%BE9.png)

所使用的约束如下：

```
// 垂直约束
Red.top = 1.0 * Superview.top + 20.0
Superview.bottom = 1.0 * Red.bottom + 20.0
Blue.top = 1.0 * Superview.top + 20.0
Superview.bottom = 1.0 * Blue.bottom + 20.0
 
// 水平约束
Red.leading = 1.0 * Superview.leading + 20.0
Blue.leading = 1.0 * Red.trailing + 8.0
Superview.trailing = 1.0 * Blue.trailing + 20.0
Red.width = 1.0 * Blue.width + 0.0
```

根据之前提到的规则，此布局包含两个视图，意味着有四个水平约束，四个垂直约束。虽然这条规则并不绝对，但能够让你迅速上手。更重要的是，两个视图的尺寸和位置都有且仅有唯一约束，从而让布局明确，可满足。去除任意一条约束，布局会变得模糊。添加额外约束，可能会产生冲突。

当然，布局的方式不仅一种。下述方式同样有效：

![图10](http://ohqrsnfvu.bkt.clouddn.com/auto-layout-guide/%E5%9B%BE10.png) 

没有根据父视图约束蓝色视图的上部和下部，而是根据红色视图。具体约束如下：

```
// Vertical Constraints
Red.top = 1.0 * Superview.top + 20.0
Superview.bottom = 1.0 * Red.bottom + 20.0
Red.top = 1.0 * Blue.top + 0.0
Red.bottom = 1.0 * Blue.bottom + 0.0
 
//Horizontal Constraints
Red.leading = 1.0 * Superview.leading + 20.0
Blue.leading = 1.0 * Red.trailing + 8.0
Superview.trailing = 1.0 * Blue.trailing + 20.0
Red.width = 1.0 * Blue.width + 0.0
```

仍然是两个视图，每个方向上四条约束。生成的布局仍然是明确，可满足的。 

>哪个更好？
>
>两种方式产生的布局都没问题。但哪个更好呢？
>
>不幸的事，无法客观的评判孰优孰劣。每种方式都有其优缺点。
>
>对于第一种方式，如果移除子视图，对布局影响较小。从视图结构中移除视图会同时移除与其相关的所有约束。所以，如果移除了红色视图，蓝色视图就还剩三条约束，只需再添加一条约束即可。而对于第二种方式，红色视图的移除意味着蓝色视图只剩下一条约束。
>
>另一方面，对于第一中方式，如果想要对齐所有子视图的上部和下部，就要保证相对于父视图，所使用的偏移常量都相同。修改一处，其他地方也要修改。

#### Constraint Inequalities（不等关系型约束）

目前为止，例子中的所有约束都是相等关系，但这并不是全部。约束也可以通过不等关系定义。所以，约束的关系可是相等，大于等于，或小于等于。

例如，定义视图的尺寸的最大值和最小值（代码 3-3）。

**代码 3-3** 通过约束设置尺寸的最大值和最小值

```
// 设置最小宽度
View.width >= 0.0 * NotAnAttribute + 40.0
 
// 设置最大宽度
View.width <= 0.0 * NotAnAttribute + 280.0
```

一旦使用不等关系，每个视图每个方向上两条约束的规则随之无效。此时，一个相等约束，等同于两个不等约束。代码3-4中，一个相等规则的效果和两个不等规则的效果相同。

**代码 3-4** 用两个不等约束代替一个相等约束

```
// 一个相等约束
Blue.leading = 1.0 * Red.trailing + 8.0
 
// 可以被两个不等约束替代
Blue.leading >= 1.0 * Red.trailing + 8.0
Blue.leading <= 1.0 * Red.trailing + 8.0
```

这种替代方式并不一定可行，因为两个不等约束并不总是等同于一个相等约束。例如，[代码3-3](https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/AnatomyofaConstraint.html#//apple_ref/doc/uid/TP40010853-CH9-SW10)中的不等约束限制了视图宽度的范围——但其本身并没有定义宽度的具体值。此时，仍需要定义额外的水平约束，为视图的宽度设置一个上述范围内的具体值。

#### Constraint Priorities（约束优先级）

所有约束的默认优先级都是最高级：必要（reqiured）。自动布局会考虑所有约束，以此为基础计算唯一解，否则，错误出现。无法满足的约束信息会输出至控制台，其中一个约束会被打破（即忽略）。之后，自动布局会针对剩余约束重新计算，直至得出唯一解。更多信息，详见[无法满足的约束](https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/ConflictingLayouts.html#//apple_ref/doc/uid/TP40010853-CH19-SW1)。

还可以创建可选约束。约束的优先级从1到1000。优先级为1000的约束被称为必要约束。剩下的都是可选约束。

计算时，自动布局会按照优先级考虑所有约束，首先满足优先级高的。因此，无法满足的可选约束会被自动跳过。

虽然无法被满足，可选约束仍然可以对布局产生影响。如果歧义，可选约束将提供"退而求其次"的解决方案：即满足现有布局的最接近可选约束的约束。因此，可选约束更倾向于作为一种束缚布局的趋势存在。例如，有可选约束`a == b`，即使其无法被满足，自动布局也会将`abs(a - b)`的值最小化。

可选和不等约束经常被一起使用。例如，我们可以为**代码3-4**中的不等约束设置不同的优先级。大于等于的约束优先级为必要（1000），小于等于的约束优先级较低（250）。这意味着蓝色和红色视图的间距至少为8.0pt。但鉴于其他约束可以扩大这个间距，可选约束的存在使得两个视图之间的距离有接近8.0pt的趋势（虽然无法被完全满足）。

>注意
>
>不一定所有约束的优先级都必须是1000。事实上，优先级一般分布在系统定义的四档上：低（250），中（500），高（750）以及必要（1000）。有时，为了防止优先级相同所产生的冲突，可能需要微调一两个点。但如果需要为每个约束设定具体的优先级，那么很可能布局的方式有问题。
>
>更多关于iOS的优先级信息，详见枚举[UILayoutPriority](https://developer.apple.com/documentation/uikit/uilayoutpriority)。至于OS X，详见章节布局优先级常量。

#### Intrinsic Content Size（固有尺寸）

目前为止，所有的例子中视图的尺寸和位置都得到了约束。然而，某些视图会根据其当前内容拥有一个尺寸，被称为固有尺寸。例如，按钮的固有尺寸是其标题的尺寸加上四周边距。（译者：这里指的是按钮只有标题，没有图片的情况）

不是所有视图都有固有尺寸。而且，即便有，固有尺寸也可能只定义视图宽高中的一项。表3-1提供了一些例子：

**表 3-1** 常见控件的固有尺寸

视图  | 固有尺寸
------------- | -------------
UIView和NSView  | 没有
滑块控件  | 只定义宽度（iOS）<br>根据其类型不同，定义高度，宽度或同时定义（OS X）
标签，按钮，开关和文本框  | 同时定义宽度和高度
文本视图（text view）和图片视图（image view）  | 尺寸根据内容变化


固有尺寸基于视图当前的内容产生。标签或按钮的固有尺寸同文字和字体有关。而其他视图的固有尺寸计算方式更为复杂。例如，一个空的图片视图没有固有尺寸。但一旦为其添加图片，图片尺寸就是其固有尺寸。

文本视图的固有尺寸会根据文字内容，滚动是否开启，以及本身的其他约束变化。例如，开启滚动时，视图没有固有尺寸。关闭时，固有尺寸默认为不折行的文字内容大小。假设没有回车，文本会作为一行文字计算所占空间。如果约束了文本视图的宽度，那么固有尺寸就是在特定宽度下显示完整文本所需的高度。

对于自动布局来说，固有尺寸做为约束影响视图的实际尺寸，其通过两个属性，影响视图的宽高。内缩属性代表向内收缩的趋势，以便视图紧紧包裹其内容；外扩属性代表向外伸展的趋势，以便视图的边缘不会裁剪其内容。

![图11]()

代码3-5中通过不等式定义了固有尺寸影响下视图的尺寸。其中`IntrinsicWidth`和`IntrinsicHeight`分别代表固有尺寸的宽和高。

**代表 3-5** 外扩和内缩与固有尺寸一起形成约束，决定视图的尺寸

```
// 外扩属性
View.height >= 0.0 * NotAnAttribute + IntrinsicHeight
View.width >= 0.0 * NotAnAttribute + IntrinsicWidth
 
// 内缩属性
View.height <= 0.0 * NotAnAttribute + IntrinsicHeight
View.width <= 0.0 * NotAnAttribute + IntrinsicWidth
```

上述约束各有自己的优先级。默认，内缩约束的优先级为250，外扩约束的优先级为750。因此，伸展视图要比压缩视图容易。例如，按钮可以随意放大，但如果要缩小它，其内容就可能受到裁剪。注意界面编辑器（Interface Builder）有时会自动修改上述约束的优先级，以防止冲突发生。更多信息，详见[设置内缩和外扩优先级](https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/WorkingwithConstraintsinInterfaceBuidler.html#//apple_ref/doc/uid/TP40010853-CH10-SW2)。

如果可能，尽量使用视图的固有尺寸。这可以让布局动态响应视图内容的变化，同时也减少了需要定义的约束的数量。但需要注意视图的内缩和外扩优先级。使用固有尺寸时的基本原则如下：

- 当拉伸多个视图，以填满空间时，如果所有视图的内缩优先级都一样，布局就会产生歧义。因为自动布局不知道应该拉伸哪个视图。

	一个常见的例子是标签和文本框在一起时。通常，文本框应该被拉伸，而标签保持其固有尺寸。为此，要确保文本框的水平内缩优先级小于标签的。
	
	事实上，这个例子太常见了，以至于界面编辑器遇到这种情况会自动处理：将所有标签的内缩优先级设置为251。但使用代码布局时，这里需要手动修改。
	
- 某些诡异布局就是因为透明背景色的视图（例如按钮和标签）被意外拉伸所致。很难立即发现问题，因为我们只能看到文字的位置不正确。要防止以外拉伸的情况，可以增加内缩优先级。
- 基准线约束只在视图的高度是其固有高度时有效。如果视图在垂直放线上压缩或拉伸，则基准线约束无法正确对齐。（译者：事实上我从未用过这个约束，所以这里的理解可能有误。🤔）
- 诸如开关的视图，最好使用固有尺寸。适当调整外扩和内缩优先级，防止变形。
- 尽量避免设置最高优先级（即"必要"）。对于布局来说，视图尺寸错误总比造成约束冲突要好。如果视图必须使用固有尺寸，将其优先级设置为999。这种方式总能让视图保持固有尺寸，同时也给意外情况留下回旋余地，例如父视图的尺寸要比预想的或大或小。

#### Intrinsic Content Size Versus Fitting Size（固有尺寸和可容纳尺寸）

（译者：这里的可容纳尺寸指的是函数`systemLayoutSizeFittingSize:`的结果。🤔）

对于自动布局来说，固有尺寸是输入。如果视图有固有尺寸，自动布局会据此产生约束，定义视图的尺寸，进行布局。

而可容纳尺寸，是自动布局的输出。即根据视图的约束计算视图的尺寸。如果父视图使用约束布局子视图，那么根据其内容（子视图）计算出的可容纳尺寸，就是父视图的尺寸。

以堆叠视图为例。如果不添加其他约束，堆叠视图的尺寸就是其内容的尺寸。在很多方面，堆叠视图貌似有固有尺寸：只需添加位置约束，就可以正确布局堆叠视图。但实际上，其尺寸是自动布局计算的输出——而非计算的输入（译者：即自动布局告诉堆叠视图它有多大，而非堆叠视图告诉自动布局自己有多大🤔）。设置堆叠视图的外扩和内缩优先级没用，因为它没有固有尺寸。

如果需要根据其他视图调整堆叠视图的尺寸（这个视图不属于堆叠视图），要么创建约束，要么相对于这个视图调整堆叠视图内容的外扩和内缩优先级。


#### Interpreting Values（解释数值）

自动布局中数值的单位是点（points）。然而，这些值的意义会根据参与的属性和布局方向的不同具有不同的含义。

属性  | 数值的含义 | 备注
------------- | ------------- | -------------
高 / 宽（Height/Width）  | 视图的尺寸 | 可以设置常量，也可以相对于其他宽高约束。不能为负。
上部 / 下部 / 基准线（Top/Bottom/Baseline） | 越靠屏幕下方，数值越大 | 只能相对于垂直中心，上部，下部和基准线约束。
头部 / 尾部（Leading/Trailing） | 越靠近尾部，数值越大。对于自左至右的文字方向，越靠右数值越大；相反，越靠左数值越大。 | 只能相对于前部，后部和水平中心约束。
左部 / 右部（Left/Right） | 越靠右数值越大。 | 只能相对于左部，右部和水平中心约束。<br>尽量使用前部 / 后部，而非左部 / 右部，这样布局能够根据文字方向做出改变。<br>默认，文字方向总是和设备当前语言一致。通过设置视图的[semanticContentAttribute](https://developer.apple.com/documentation/uikit/uiview/1622461-semanticcontentattribute)属性，决定文字方向改变时视图内容方向是否也改变。
水平中心 / 垂直中心（Center X/Center Y） | 数值的具体含义取决于约束中的其他属性 | 水平中心可以相对于水平中心，头部，尾部，右部和左部约束。<br>垂直中心可以相对于垂直中心，上部，下部，基准线约束。
