# 翻译@Auto Layout Guide（自动布局指南）

- 原文：[Auto Layout Guide](https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/index.html#//apple_ref/doc/uid/TP40010853)
- 作者：[Apple](https://developer.apple.com/library/content/navigation/)

---

## Advanced Auto Layout（自动布局进阶使用）

### Changing Constraints（变更约束）

任何对约束方程的修改，都将变更约束（见图17-1）。更多信息，详见章节[Anatomy of a Constraint（约束详解）](https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/AnatomyofaConstraint.html#//apple_ref/doc/uid/TP40010853-CH9-SW1)。

图17-1

![图67](http://ohqrsnfvu.bkt.clouddn.com/auto-layout-guide/%E5%9B%BE67.png)

下述操作变更一个或多个约束：

- 激活或撤销一个约束（Activate / Deactivate）；
- 修改常量；
- 修改优先级；
- 从视图结构中移除视图。

其他诸如设置属性，更改视图结构等修改，也可能变更约束。变更发生后，系统将安排一次延期更新（详见[The Deferred Layout Pass（布局延期更新）](https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/ModifyingConstraints.html#//apple_ref/doc/uid/TP40010853-CH29-SW3)）。

通常，约束都是提前设置好的，要么借助IB，要么在控制器初始化时（如[viewDidLoad](https://developer.apple.com/documentation/uikit/uiviewcontroller/1621495-viewdidload)）代码创建。但我们可以随时随地变更它们。在运行时，如果需要，约束应该根据App状态改变。例如，点击按钮，布局变化，变更约束的代码存在于点击方法中。

有时，出于性能原因，最好批量变更约束。相关信息，详见[Batching Changes（批量变更）](https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/ModifyingConstraints.html#//apple_ref/doc/uid/TP40010853-CH29-SW2)。

#### The Deferred Layout Pass（布局延期更新）

变更约束不会导致视图frame立即更新。系统会安排一轮布局更新，在近期执行（所以称之为延期更新），更新所有约束，根据新约束计算所有视图frame。

也可以调用视图方法[setNeedsLayout](https://developer.apple.com/documentation/uikit/uiview/1622601-setneedslayout)或[setNeedsUpdateConstraints](https://developer.apple.com/documentation/uikit/uiview/1622450-setneedsupdateconstraints)主动安排一轮布局更新。

延期更新会对视图结构进行两轮遍历：

1. 根据需要，更新所有约束；
2. 根据需要，更新所有视图frame。

##### Update Pass（更新约束）

遍历所有控制器，调用控制器方法[updateViewConstraints](https://developer.apple.com/documentation/uikit/uiviewcontroller/1621379-updateviewconstraints)；遍历所有视图，调用视图方法[updateConstraints](https://developer.apple.com/documentation/uikit/uiview/1622512-updateconstraints)。通过重写上述方法，我们可以优化约束更新逻辑[Batching Changes（批量变更）](https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/ModifyingConstraints.html#//apple_ref/doc/uid/TP40010853-CH29-SW2)。

##### Layout Pass（更新frame）

遍历所有控制器，调用控制器方法[viewWillLayoutSubviews](https://developer.apple.com/documentation/uikit/uiviewcontroller/1621437-viewwilllayoutsubviews)；遍历所有视图，调用视图方法[layoutSubviews](https://developer.apple.com/documentation/uikit/uiview/1622482-layoutsubviews)（[layout](https://developer.apple.com/documentation/appkit/nsview/1526146-layout)，在OS X中）。默认，视图方法[layoutSubviews](https://developer.apple.com/documentation/uikit/uiview/1622482-layoutsubviews)根据自动布局引擎的计算结果更新子视图frame。通过重写上述方法，我们可以进一步修改布局（详见[Custom Layouts（自定义布局）](https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/ModifyingConstraints.html#//apple_ref/doc/uid/TP40010853-CH29-SW4)）。

记号

#### Batching Changes（批量变更）

一般来说，一旦触发更改，就应该立即更新约束。将触发与更新分离，会增加代码理解难度。

但有时，为了优化性能，我们必须积攒更改，批量更新约束。例如，当需要更新的约束太多，极大的影响性能时，或更新只是冗余重复时。

批量更新时，不要原地修改约束，而是调用对应视图方法[setNeedsUpdateConstraints](https://developer.apple.com/documentation/uikit/uiview/1622450-setneedsupdateconstraints)。同时，我们应该重写对应视图方法[updateConstraints](https://developer.apple.com/documentation/uikit/uiview/1622512-updateconstraints)，在其中一同修改所有受影响的约束。

>注意
>
>视图方法[updateConstraints](https://developer.apple.com/documentation/uikit/uiview/1622512-updateconstraints)的实现必须做到简洁高效。不要仅用所有约束，然后根据需要重新启用。相反，app必须追踪约束状态，在每轮更新时验证其状态。只更新受到修改的。每轮更新时，必须确保约束状态与app状态保持一致。

实现视图方法[updateConstraints](https://developer.apple.com/documentation/uikit/uiview/1622512-updateconstraints)时，不要忘记在最后调用`super`作为结尾。

不要在[updateConstraints](https://developer.apple.com/documentation/uikit/uiview/1622512-updateconstraints)中调用[setNeedsUpdateConstraints](https://developer.apple.com/documentation/uikit/uiview/1622450-setneedsupdateconstraints)。因为后者将触发一轮新的更新轮，从而中造成循环调用。

#### Custom Layouts（自定义布局）

通过重写视图方法[viewWillLayoutSubviews](https://developer.apple.com/documentation/uikit/uiviewcontroller/1621437-viewwilllayoutsubviews) 以及[layoutSubviews](https://developer.apple.com/documentation/uikit/uiview/1622482-layoutsubviews)，我们可以修改自动布局引擎产生的结果。

>重要
>
>尽量使用约束定义布局，因为这种方式产生的布局更健壮，更容易Debug。除非约束无法满足需要，否则不要重写视图方法[viewWillLayoutSubviews](https://developer.apple.com/documentation/uikit/uiviewcontroller/1621437-viewwilllayoutsubviews) 以及[layoutSubviews](https://developer.apple.com/documentation/uikit/uiview/1622482-layoutsubviews)。


上述方法的重写，将导致布局出现不一致状态：有些视图布局合法，有些不是。修改视图结构时，必须十分小心，否则将造成循环调用。下述规则可以帮助我们避免循环调用：

- 必须在实现中调用`super`；
- 可以在实现中撤销子树中所有视图的布局状态，但这项操作只能放在调用`super`之前；
- 不要在撤销子树之外视图的布局状态，这将导致引用循环；
- 不要在实现中调用[setNeedsUpdateConstraints](https://developer.apple.com/documentation/uikit/uiview/1622450-setneedsupdateconstraints)。因为我们刚刚完整一轮更新，调用这个方法将造成循环调用；
- 不要调用[setNeedsLayout](https://developer.apple.com/documentation/uikit/uiview/1622601-setneedslayout)，将导致循环调用；
- 修改约束时要小心，不要在撤销子树之外视图的布局状态。